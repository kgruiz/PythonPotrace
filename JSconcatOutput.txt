Contents of 'LocalPotraceJS' and its subdirectories
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

--------------------------------------------------------------------------------
# Tree Representation
********************************************************************************
Full tree of 'LocalPotraceJS':

LocalPotraceJS
├── LICENSE
├── README.md
├── concatOutput.txt
├── lib
│   ├── Posterizer.js
│   ├── Potrace.js
│   ├── index.js
│   ├── types
│   │   ├── Bitmap.js
│   │   ├── Curve.js
│   │   ├── Histogram.js
│   │   ├── Opti.js
│   │   ├── Path.js
│   │   ├── Point.js
│   │   ├── Quad.js
│   │   └── Sum.js
│   └── utils.js
├── out.json
├── out.png
├── package-lock.json
└── package.json

3 directories, 19 files
================================================================================

--------------------------------------------------------------------------------
# Filtered Directory Structure List
********************************************************************************
".": ["LICENSE, README.md, concatOutput.txt, lib, out.json, out.png, package-lock.json, package.json"]
"./lib": ["Posterizer.js, Potrace.js, index.js, types, utils.js"]
"./lib/types": ["Bitmap.js, Curve.js, Histogram.js, Opti.js, Path.js, Point.js, Quad.js, Sum.js"]
================================================================================

--------------------------------------------------------------------------------
# Histogram.js
# lib/types/Histogram.js
# ./lib/types/Histogram.js
# Content:
********************************************************************************
// histogram.js
'use strict';

// Histogram

var utils = require('../utils');
var Jimp = null;
try {
    Jimp = require('jimp');
} catch (e) {
}
var Bitmap = require('./Bitmap');

var COLOR_DEPTH = 256;
var COLOR_RANGE_END = COLOR_DEPTH - 1;

/**
 * Calculates array index for pair of indexes. We multiple column (x) by 256 and then add
 * row to it, this way `(index(i, j) + 1) === index(i, j + i)` thus we can reuse `index(i,
 * j)` we once calculated
 *
 * Note: this is different from how indexes calculated in {@link Bitmap} class, keep it in
 * mind.
 *
 * @param x
 * @param y
 * @returns {*}
 * @private
 */
function index(x, y) {
    return COLOR_DEPTH * x + y;
}

function normalizeMinMax(levelMin, levelMax) {
    /**
     * Shared parameter normalization for methods 'multilevelThresholding',
     * 'autoThreshold', 'getDominantColor' and 'getStats'
     *
     * @param levelMin
     * @param levelMax
     * @returns {number[]}
     * @private
     */
    levelMin = typeof levelMin === 'number' ?
                   utils.clamp(Math.round(levelMin), 0, COLOR_RANGE_END) :
                   0;
    levelMax = typeof levelMax === 'number' ?
                   utils.clamp(Math.round(levelMax), 0, COLOR_RANGE_END) :
                   COLOR_RANGE_END;

    if (levelMin > levelMax) {
        throw new Error('Invalid range "' + levelMin + '...' + levelMax + '"');
    }

    return [levelMin, levelMax];
}

/**
 * 1D Histogram
 *
 * @param {Number|Bitmap|Jimp} imageSource - Image to collect pixel data from. Or integer
 *     to create empty histogram for image of specific size
 * @param [mode] Used only for Jimp images. {@link Bitmap} currently can only store 256
 *     values per pixel, so it's assumed that it contains values we are looking for
 * @constructor
 * @protected
 */
function Histogram(imageSource, mode) {
    this.data = null;
    this.pixels = 0;
    this._sortedIndexes = null;
    this._cachedStats = {};
    this._lookupTableH = null;

    if (typeof imageSource === 'number') {
        this._createArray(imageSource);
    } else if (imageSource instanceof Bitmap) {
        this._collectValuesBitmap(imageSource);
    } else if (Jimp && imageSource instanceof Jimp) {
        this._collectValuesJimp(imageSource, mode);
    } else {
        throw new Error('Unsupported image source');
    }
}

Histogram.MODE_LUMINANCE = 'luminance';
Histogram.MODE_R = 'r';
Histogram.MODE_G = 'g';
Histogram.MODE_B = 'b';

Histogram.prototype = {
    /**
     * Initializes data array for an image of given pixel size
     * @param imageSize
     * @returns {Uint8Array|Uint16Array|Uint32Array}
     * @private
     */
    _createArray: function(imageSize) {
        var ArrayType = imageSize <= Math.pow(2, 8)  ? Uint8Array :
                        imageSize <= Math.pow(2, 16) ? Uint16Array :
                                                       Uint32Array;

        this.pixels = imageSize;

        return this.data = new ArrayType(COLOR_DEPTH);
    },

    /**
     * Aggregates color data from {@link Jimp} instance
     * @param {Jimp} source
     * @param mode
     * @private
     */
    _collectValuesJimp: function(source, mode) {
        var pixelData = source.bitmap.data;
        var data = this._createArray(source.bitmap.width * source.bitmap.height);

        source.scan(0, 0, source.bitmap.width, source.bitmap.height, function(x, y, idx) {
            var val = mode === Histogram.MODE_R ? pixelData[idx] :
                      mode === Histogram.MODE_G ? pixelData[idx + 1] :
                      mode === Histogram.MODE_B ? pixelData[idx + 2] :
                                                  utils.luminance(pixelData[idx],
                                                                  pixelData[idx + 1],
                                                                  pixelData[idx + 2]);

            data[val]++;
        });
    },

    /**
     * Aggregates color data from {@link Bitmap} instance
     * @param {Bitmap} source
     * @private
     */
    _collectValuesBitmap: function(source) {
        var data = this._createArray(source.size);
        var len = source.data.length;
        var color;

        for (var i = 0; i < len; i++) {
            color = source.data[i];
            data[color]++
        }
    },

    /**
     * Returns array of color indexes in ascending order
     * @param refresh
     * @returns {*}
     * @private
     */
    _getSortedIndexes: function(refresh) {
        if (!refresh && this._sortedIndexes) {
            return this._sortedIndexes;
        }

        var data = this.data;
        var indexes = new Array(COLOR_DEPTH);
        var i = 0;

        for (i; i < COLOR_DEPTH; i++) {
            indexes[i] = i;
        }

        indexes.sort(function(a, b) {
            return data[a] > data[b] ? 1 : data[a] < data[b] ? -1 : 0;
        });

        this._sortedIndexes = indexes;
        return indexes;
    },

    /**
     * Builds lookup table H from lookup tables P and S.
     * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper}
     * for more details
     *
     * @returns {Float64Array}
     * @private
     */
    _thresholdingBuildLookupTable: function() {
        var P = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var S = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var H = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var pixelsTotal = this.pixels;
        var i, j, idx, tmp;

        // diagonal
        for (i = 1; i < COLOR_DEPTH; ++i) {
            idx = index(i, i);
            tmp = this.data[i] / pixelsTotal;

            P[idx] = tmp;
            S[idx] = i * tmp;
        }

        // calculate first row (row 0 is all zero)
        for (i = 1; i < COLOR_DEPTH - 1; ++i) {
            tmp = this.data[i + 1] / pixelsTotal;
            idx = index(1, i);

            P[idx + 1] = P[idx] + tmp;
            S[idx + 1] = S[idx] + (i + 1) * tmp;
        }

        // using row 1 to calculate others
        for (i = 2; i < COLOR_DEPTH; i++) {
            for (j = i + 1; j < COLOR_DEPTH; j++) {
                P[index(i, j)] = P[index(1, j)] - P[index(1, i - 1)];
                S[index(i, j)] = S[index(1, j)] - S[index(1, i - 1)];
            }
        }

        // now calculate H[i][j]
        for (i = 1; i < COLOR_DEPTH; ++i) {
            for (j = i + 1; j < COLOR_DEPTH; j++) {
                idx = index(i, j);
                H[idx] = P[idx] !== 0 ? S[idx] * S[idx] / P[idx] : 0;
            }
        }

        return this._lookupTableH = H;
    },

    /**
     * Implements Algorithm For Multilevel Thresholding
     * Receives desired number of color stops, returns array of said size. Could be
     * limited to a range levelMin..levelMax
     *
     * Regardless of levelMin and levelMax values it still relies on between class
     * variances for the entire histogram
     *
     * @param amount - how many thresholds should be calculated
     * @param [levelMin=0] - histogram segment start
     * @param [levelMax=255] - histogram segment end
     * @returns {number[]}
     */
    multilevelThresholding: function(amount, levelMin, levelMax) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];
        amount = Math.min(levelMax - levelMin - 2, ~~amount);

        if (amount < 1) {
            return [];
        }

        if (!this._lookupTableH) {
            this._thresholdingBuildLookupTable();
        }

        var H = this._lookupTableH;

        var colorStops = null;
        var maxSig = 0;

        if (amount > 4) {
            console.log(
                '[Warning]: Threshold computation for more than 5 levels may take a long time');
        }

        function iterateRecursive(startingPoint, prevVariance, indexes, previousDepth) {
            startingPoint = (startingPoint || 0) + 1;
            prevVariance = prevVariance || 0;
            indexes = indexes || (new Array(amount));
            previousDepth = previousDepth || 0;

            var depth = previousDepth + 1;  // t
            var variance;

            for (var i = startingPoint; i < levelMax - amount + previousDepth; i++) {
                variance = prevVariance + H[index(startingPoint, i)];
                indexes[depth - 1] = i;

                if (depth + 1 < amount + 1) {
                    // we need to go deeper
                    iterateRecursive(i, variance, indexes, depth);
                } else {
                    // enough, we can compare values now
                    variance += H[index(i + 1, levelMax)];

                    if (maxSig < variance) {
                        maxSig = variance;
                        colorStops = indexes.slice();
                    }
                }
            }
        }

        iterateRecursive(levelMin || 0);

        return colorStops ? colorStops : [];
    },

    /**
     * Automatically finds threshold value using Algorithm For Multilevel Thresholding
     *
     * @param {number} [levelMin]
     * @param {number} [levelMax]
     * @returns {null|number}
     */
    autoThreshold: function(levelMin, levelMax) {
        var value = this.multilevelThresholding(1, levelMin, levelMax);
        return value.length ? value[0] : null;
    },

    /**
     * Returns dominant color in given range. Returns -1 if not a single color from the
     * range present on the image
     *
     * @param [levelMin=0]
     * @param [levelMax=255]
     * @param [tolerance=1]
     * @returns {number}
     */
    getDominantColor: function(levelMin, levelMax, tolerance) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];
        tolerance = tolerance || 1;

        var colors = this.data, dominantIndex = -1, dominantValue = -1, i, j, tmp;

        if (levelMin === levelMax) {
            return colors[levelMin] ? levelMin : -1;
        }

        for (i = levelMin; i <= levelMax; i++) {
            tmp = 0;

            for (j = ~~(tolerance / -2); j < tolerance; j++) {
                tmp += utils.between(i + j, 0, COLOR_RANGE_END) ? colors[i + j] : 0;
            }

            var summIsBigger = tmp > dominantValue;
            var summEqualButMainColorIsBigger =
                dominantValue === tmp &&
                (dominantIndex < 0 || colors[i] > colors[dominantIndex]);

            if (summIsBigger || summEqualButMainColorIsBigger) {
                dominantIndex = i;
                dominantValue = tmp;
            }
        }

        return dominantValue <= 0 ? -1 : dominantIndex;
    },

    /**
     * Returns stats for histogram or its segment.
     *
     * Returned object contains median, mean and standard deviation for pixel values;
     * peak, mean and median number of pixels per level and few other values
     *
     * If no pixels colors from specified range present on the image - most values will be
     * NaN
     *
     * @param {Number} [levelMin=0] - histogram segment start
     * @param {Number} [levelMax=255] - histogram segment end
     * @param {Boolean} [refresh=false] - if cached result can be returned
     * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number},
     *     pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels:
     *     number}}
     */
    getStats: function(levelMin, levelMax, refresh) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];

        if (!refresh && this._cachedStats[levelMin + '-' + levelMax]) {
            return this._cachedStats[levelMin + '-' + levelMax];
        }

        var data = this.data;
        var sortedIndexes = this._getSortedIndexes();

        var pixelsTotal = 0;
        var medianValue = null;
        var meanValue;
        var medianPixelIndex;
        var pixelsPerLevelMean;
        var pixelsPerLevelMedian;
        var tmpSumOfDeviations = 0;
        var tmpPixelsIterated = 0;
        var allPixelValuesCombined = 0;
        var i, tmpPixels, tmpPixelValue;

        var uniqueValues =
            0;  // counter for levels that's represented by at least one pixel
        var mostPixelsPerLevel = 0;

        // Finding number of pixels and mean

        for (i = levelMin; i <= levelMax; i++) {
            pixelsTotal += data[i];
            allPixelValuesCombined += data[i] * i;

            uniqueValues += data[i] === 0 ? 0 : 1;

            if (mostPixelsPerLevel < data[i]) {
                mostPixelsPerLevel = data[i];
            }
        }

        meanValue = allPixelValuesCombined / pixelsTotal;
        pixelsPerLevelMean = pixelsTotal / (levelMax - levelMin);
        pixelsPerLevelMedian = pixelsTotal / uniqueValues;
        medianPixelIndex = Math.floor(pixelsTotal / 2);

        // Finding median and standard deviation

        for (i = 0; i < COLOR_DEPTH; i++) {
            tmpPixelValue = sortedIndexes[i];
            tmpPixels = data[tmpPixelValue];

            if (tmpPixelValue < levelMin || tmpPixelValue > levelMax) {
                continue;
            }

            tmpPixelsIterated += tmpPixels;
            tmpSumOfDeviations += Math.pow(tmpPixelValue - meanValue, 2) * tmpPixels;

            if (medianValue === null && tmpPixelsIterated >= medianPixelIndex) {
                medianValue = tmpPixelValue;
            }
        }

        return this._cachedStats[levelMin + '-' + levelMax] = {
            // various pixel counts for levels (0..255)

            levels: {
                mean: meanValue,
                median: medianValue,
                stdDev: Math.sqrt(tmpSumOfDeviations / pixelsTotal),
                unique: uniqueValues
            },

            // what's visually represented as bars
            pixelsPerLevel: {
                mean: pixelsPerLevelMean,
                median: pixelsPerLevelMedian,
                peak: mostPixelsPerLevel
            },

            pixels: pixelsTotal
        };
    }
};

module.exports = Histogram;
================================================================================
--------------------------------------------------------------------------------
# Opti.js
# lib/types/Opti.js
# ./lib/types/Opti.js
# Content:
********************************************************************************
// Opti.js
'use strict';

var Point = require('./Point');

function Opti() {
    this.pen = 0;
    this.c = [new Point(), new Point()];
    this.t = 0;
    this.s = 0;
    this.alpha = 0;
}

module.exports = Opti;
================================================================================
--------------------------------------------------------------------------------
# Quad.js
# lib/types/Quad.js
# ./lib/types/Quad.js
# Content:
********************************************************************************
// Quad.js
'use strict';

function Quad() {
    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
}

Quad.prototype.at = function(x, y) {
    return this.data[x * 3 + y];
};

module.exports = Quad;
================================================================================
--------------------------------------------------------------------------------
# Sum.js
# lib/types/Sum.js
# ./lib/types/Sum.js
# Content:
********************************************************************************
// Sum.js
'use strict';

function Sum(x, y, xy, x2, y2) {
    this.x = x;
    this.y = y;
    this.xy = xy;
    this.x2 = x2;
    this.y2 = y2;
}

module.exports = Sum;
================================================================================
--------------------------------------------------------------------------------
# Bitmap.js
# lib/types/Bitmap.js
# ./lib/types/Bitmap.js
# Content:
********************************************************************************
// Bitmap.js
'use strict';

var Point = require('./Point');
var utils = require('../utils');
var Histogram;

/**
 * Represents a bitmap where each pixel can be a number in range of 0..255
 * Used internally to store luminance data.
 *
 * @param {Number} w
 * @param {Number} h
 * @constructor
 */
function Bitmap(w, h) {
    this._histogram = null;

    this.width = w;
    this.height = h;
    this.size = w * h;
    this.arrayBuffer = new ArrayBuffer(this.size);
    this.data = new Uint8Array(this.arrayBuffer);
}

module.exports = Bitmap;
Histogram = require('./Histogram');

Bitmap.prototype = {
    /**
     * Returns pixel value
     *
     * @param {Number|Point} x - index, point or x
     * @param {Number} [y]
     */
    getValueAt: function(x, y) {
        var index = (typeof x === 'number' && typeof y !== 'number') ?
                        x :
                        this.pointToIndex(x, y);
        return this.data[index];
    },

    /**
     * Converts {@link Point} to index value
     *
     * @param {Number} index
     * @returns {Point}
     */
    indexToPoint: function(index) {
        var point = new Point();

        if (utils.between(index, 0, this.size)) {
            point.y = Math.floor(index / this.width);
            point.x = index - point.y * this.width;
        } else {
            point.x = -1;
            point.y = -1;
        }

        return point;
    },

    /**
     * Calculates index for point or coordinate pair
     *
     * @param {Number|Point} pointOrX
     * @param {Number} [y]
     * @returns {Number}
     */
    pointToIndex: function(pointOrX, y) {
        var _x = pointOrX, _y = y;

        if (pointOrX instanceof Point) {
            _x = pointOrX.x;
            _y = pointOrX.y;
        }

        if (!utils.between(_x, 0, this.width) || !utils.between(_y, 0, this.height)) {
            return -1;
        }

        return this.width * _y + _x;
    },

    /**
     * Makes a copy of current bitmap
     *
     * @param {Function} [iterator] optional callback, used for processing pixel value.
     *     Accepted arguments: value, index
     * @returns {Bitmap}
     */
    copy: function(iterator) {
        var bm = new Bitmap(this.width, this.height),
            iteratorPresent = typeof iterator === 'function', i;

        for (i = 0; i < this.size; i++) {
            bm.data[i] = iteratorPresent ? iterator(this.data[i], i) : this.data[i];
        }

        return bm;
    },

    histogram: function() {
        var Histogram = require('./Histogram');

        if (this._histogram) {
            return this._histogram;
        }

        this._histogram = new Histogram(this);
        return this._histogram;
    }
};
================================================================================
--------------------------------------------------------------------------------
# Path.js
# lib/types/Path.js
# ./lib/types/Path.js
# Content:
********************************************************************************
// Path.js
'use strict';

function Path() {
    this.area = 0;
    this.len = 0;
    this.curve = {};
    this.pt = [];
    this.minX = 100000;
    this.minY = 100000;
    this.maxX = -1;
    this.maxY = -1;
}

module.exports = Path;
================================================================================
--------------------------------------------------------------------------------
# Curve.js
# lib/types/Curve.js
# ./lib/types/Curve.js
# Content:
********************************************************************************
// curve.js
'use strict';

/**
 * Curve type
 *
 * @param n
 * @constructor
 * @protected
 */
function Curve(n) {
    this.n = n;
    this.tag = new Array(n);
    this.c = new Array(n * 3);
    this.alphaCurve = 0;
    this.vertex = new Array(n);
    this.alpha = new Array(n);
    this.alpha0 = new Array(n);
    this.beta = new Array(n);
}

module.exports = Curve;
================================================================================
--------------------------------------------------------------------------------
# Point.js
# lib/types/Point.js
# ./lib/types/Point.js
# Content:
********************************************************************************
// Point.js
'use strict';

function Point(x, y) {
    this.x = x || 0;
    this.y = y || 0;
}

Point.prototype = {
    copy: function() {
        return new Point(this.x, this.y);
    }
};

module.exports = Point;
================================================================================
--------------------------------------------------------------------------------
# Potrace.js
# lib/Potrace.js
# ./lib/Potrace.js
# Content:
********************************************************************************
// Potrace.js
'use strict';

var Jimp = require('jimp');
var Bitmap = require('./types/Bitmap');
var Curve = require('./types/Curve');
var Point = require('./types/Point');
var Path = require('./types/Path');
var Quad = require('./types/Quad');
var Sum = require('./types/Sum');
var Opti = require('./types/Opti');

var utils = require('./utils');

/**
 * Potrace class
 *
 * @param {Potrace~Options} [options]
 * @constructor
 */
function Potrace(options) {
    this._luminanceData = null;
    this._pathlist = [];

    this._imageLoadingIdentifier = null;
    this._imageLoaded = false;
    this._processed = false;

    this._params = {
        turnPolicy: Potrace.TURNPOLICY_MINORITY,
        turdSize: 2,
        alphaMax: 1,
        optCurve: true,
        optTolerance: 0.2,
        threshold: Potrace.THRESHOLD_AUTO,
        blackOnWhite: true,
        color: Potrace.COLOR_AUTO,
        background: Potrace.COLOR_TRANSPARENT,
        width: null,
        height: null
    };

    if (options) {
        this.setParameters(options);
    }
}

Potrace.COLOR_AUTO = 'auto';
Potrace.COLOR_TRANSPARENT = 'transparent';
Potrace.THRESHOLD_AUTO = -1;
Potrace.TURNPOLICY_BLACK = 'black';
Potrace.TURNPOLICY_WHITE = 'white';
Potrace.TURNPOLICY_LEFT = 'left';
Potrace.TURNPOLICY_RIGHT = 'right';
Potrace.TURNPOLICY_MINORITY = 'minority';
Potrace.TURNPOLICY_MAJORITY = 'majority';

var SUPPORTED_TURNPOLICY_VALUES = [
    Potrace.TURNPOLICY_BLACK, Potrace.TURNPOLICY_WHITE, Potrace.TURNPOLICY_LEFT,
    Potrace.TURNPOLICY_RIGHT, Potrace.TURNPOLICY_MINORITY, Potrace.TURNPOLICY_MAJORITY
];

Potrace.prototype = {
    /**
     * Creating a new {@link Path} for every group of black pixels.
     * @private
     */
    _bmToPathlist: function() {
        var self = this, threshold = this._params.threshold,
            blackOnWhite = this._params.blackOnWhite, blackMap,
            currentPoint = new Point(0, 0), path;

        if (threshold === Potrace.THRESHOLD_AUTO) {
            threshold = this._luminanceData.histogram().autoThreshold() || 128;
        }

        blackMap = this._luminanceData.copy(function(lum) {
            var pastTheThreshold = blackOnWhite ? lum > threshold : lum < threshold;

            return pastTheThreshold ? 0 : 1;
        });

        /**
         * finds next black pixel of the image
         *
         * @param {Point} point
         * @returns {boolean}
         * @private
         */
        function findNext(point) {
            var i = blackMap.pointToIndex(point);

            while (i < blackMap.size && blackMap.data[i] !== 1) {
                i++;
            }

            return i < blackMap.size && blackMap.indexToPoint(i);
        }

        function majority(x, y) {
            var i, a, ct;

            for (i = 2; i < 5; i++) {
                ct = 0;
                for (a = -i + 1; a <= i - 1; a++) {
                    ct += blackMap.getValueAt(x + a, y + i - 1) ? 1 : -1;
                    ct += blackMap.getValueAt(x + i - 1, y + a - 1) ? 1 : -1;
                    ct += blackMap.getValueAt(x + a - 1, y - i) ? 1 : -1;
                    ct += blackMap.getValueAt(x - i, y + a) ? 1 : -1;
                }

                if (ct > 0) {
                    return 1;
                } else if (ct < 0) {
                    return 0;
                }
            }
            return 0;
        }

        function findPath(point) {
            var path = new Path(), x = point.x, y = point.y, dirx = 0, diry = 1, tmp;

            path.sign = blackMap.getValueAt(point.x, point.y) ? '+' : '-';

            while (1) {
                path.pt.push(new Point(x, y));
                if (x > path.maxX)
                    path.maxX = x;
                if (x < path.minX)
                    path.minX = x;
                if (y > path.maxY)
                    path.maxY = y;
                if (y < path.minY)
                    path.minY = y;
                path.len++;

                x += dirx;
                y += diry;
                path.area -= x * diry;

                if (x === point.x && y === point.y)
                    break;

                var l = blackMap.getValueAt(x + (dirx + diry - 1) / 2,
                                            y + (diry - dirx - 1) / 2);
                var r = blackMap.getValueAt(x + (dirx - diry - 1) / 2,
                                            y + (diry + dirx - 1) / 2);

                if (r && !l) {
                    if (self._params.turnPolicy === 'right' ||
                        (self._params.turnPolicy === 'black' && path.sign === '+') ||
                        (self._params.turnPolicy === 'white' && path.sign === '-') ||
                        (self._params.turnPolicy === 'majority' && majority(x, y)) ||
                        (self._params.turnPolicy === 'minority' && !majority(x, y))) {
                        tmp = dirx;
                        dirx = -diry;
                        diry = tmp;
                    } else {
                        tmp = dirx;
                        dirx = diry;
                        diry = -tmp;
                    }
                } else if (r) {
                    tmp = dirx;
                    dirx = -diry;
                    diry = tmp;
                } else if (!l) {
                    tmp = dirx;
                    dirx = diry;
                    diry = -tmp;
                }
            }
            return path;
        }

        function xorPath(path) {
            var y1 = path.pt[0].y, len = path.len, x, y, maxX, minY, i, j, indx;

            for (i = 1; i < len; i++) {
                x = path.pt[i].x;
                y = path.pt[i].y;

                if (y !== y1) {
                    minY = y1 < y ? y1 : y;
                    maxX = path.maxX;
                    for (j = x; j < maxX; j++) {
                        indx = blackMap.pointToIndex(j, minY);
                        blackMap.data[indx] = blackMap.data[indx] ? 0 : 1;
                    }
                    y1 = y;
                }
            }
        }

        // Clear path list
        this._pathlist = [];

        while (currentPoint = findNext(currentPoint)) {
            path = findPath(currentPoint);
            xorPath(path);

            if (path.area > self._params.turdSize) {
                this._pathlist.push(path);
            }
        }
    },

    /**
     * Processes path list created by _bmToPathlist method creating and optimizing {@link
     * Curve}'s
     * @private
     */
    _processPath: function() {
        var self = this;

        function calcSums(path) {
            var i, x, y;
            path.x0 = path.pt[0].x;
            path.y0 = path.pt[0].y;

            path.sums = [];
            var s = path.sums;
            s.push(new Sum(0, 0, 0, 0, 0));
            for (i = 0; i < path.len; i++) {
                x = path.pt[i].x - path.x0;
                y = path.pt[i].y - path.y0;
                s.push(new Sum(s[i].x + x, s[i].y + y, s[i].xy + x * y, s[i].x2 + x * x,
                               s[i].y2 + y * y));
            }
        }

        function calcLon(path) {

            var n = path.len, pt = path.pt, dir, pivk = new Array(n), nc = new Array(n),
                ct = new Array(4);

            path.lon = new Array(n);

            var constraint = [new Point(), new Point()], cur = new Point(),
                off = new Point(), dk = new Point(), foundk;

            var i, j, k1, a, b, c, d, k = 0;
            for (i = n - 1; i >= 0; i--) {
                if (pt[i].x != pt[k].x && pt[i].y != pt[k].y) {
                    k = i + 1;
                }
                nc[i] = k;
            }

            for (i = n - 1; i >= 0; i--) {
                ct[0] = ct[1] = ct[2] = ct[3] = 0;
                dir = (3 + 3 * (pt[utils.mod(i + 1, n)].x - pt[i].x) +
                       (pt[utils.mod(i + 1, n)].y - pt[i].y)) /
                      2;
                ct[dir]++;

                constraint[0].x = 0;
                constraint[0].y = 0;
                constraint[1].x = 0;
                constraint[1].y = 0;

                k = nc[i];
                k1 = i;
                while (1) {
                    foundk = 0;
                    dir = (3 + 3 * utils.sign(pt[k].x - pt[k1].x) +
                           utils.sign(pt[k].y - pt[k1].y)) /
                          2;
                    ct[dir]++;

                    if (ct[0] && ct[1] && ct[2] && ct[3]) {
                        pivk[i] = k1;
                        foundk = 1;
                        break;
                    }

                    cur.x = pt[k].x - pt[i].x;
                    cur.y = pt[k].y - pt[i].y;

                    if (utils.xprod(constraint[0], cur) < 0 ||
                        utils.xprod(constraint[1], cur) > 0) {
                        break;
                    }

                    if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {

                    } else {
                        off.x =
                            cur.x + ((cur.y >= 0 && (cur.y > 0 || cur.x < 0)) ? 1 : -1);
                        off.y =
                            cur.y + ((cur.x <= 0 && (cur.x < 0 || cur.y < 0)) ? 1 : -1);
                        if (utils.xprod(constraint[0], off) >= 0) {
                            constraint[0].x = off.x;
                            constraint[0].y = off.y;
                        }
                        off.x =
                            cur.x + ((cur.y <= 0 && (cur.y < 0 || cur.x < 0)) ? 1 : -1);
                        off.y =
                            cur.y + ((cur.x >= 0 && (cur.x > 0 || cur.y < 0)) ? 1 : -1);
                        if (utils.xprod(constraint[1], off) <= 0) {
                            constraint[1].x = off.x;
                            constraint[1].y = off.y;
                        }
                    }
                    k1 = k;
                    k = nc[k1];
                    if (!utils.cyclic(k, i, k1)) {
                        break;
                    }
                }
                if (foundk === 0) {
                    dk.x = utils.sign(pt[k].x - pt[k1].x);
                    dk.y = utils.sign(pt[k].y - pt[k1].y);
                    cur.x = pt[k1].x - pt[i].x;
                    cur.y = pt[k1].y - pt[i].y;

                    a = utils.xprod(constraint[0], cur);
                    b = utils.xprod(constraint[0], dk);
                    c = utils.xprod(constraint[1], cur);
                    d = utils.xprod(constraint[1], dk);

                    j = 10000000;

                    if (b < 0) {
                        j = Math.floor(a / -b);
                    }
                    if (d > 0) {
                        j = Math.min(j, Math.floor(-c / d));
                    }

                    pivk[i] = utils.mod(k1 + j, n);
                }
            }

            j = pivk[n - 1];
            path.lon[n - 1] = j;
            for (i = n - 2; i >= 0; i--) {
                if (utils.cyclic(i + 1, pivk[i], j)) {
                    j = pivk[i];
                }
                path.lon[i] = j;
            }

            for (i = n - 1; utils.cyclic(utils.mod(i + 1, n), j, path.lon[i]); i--) {
                path.lon[i] = j;
            }
        }

        function bestPolygon(path) {

            function penalty3(path, i, j) {

                var n = path.len, pt = path.pt, sums = path.sums;
                var x, y, xy, x2, y2, k, a, b, c, s, px, py, ex, ey, r = 0;
                if (j >= n) {
                    j -= n;
                    r = 1;
                }

                if (r === 0) {
                    x = sums[j + 1].x - sums[i].x;
                    y = sums[j + 1].y - sums[i].y;
                    x2 = sums[j + 1].x2 - sums[i].x2;
                    xy = sums[j + 1].xy - sums[i].xy;
                    y2 = sums[j + 1].y2 - sums[i].y2;
                    k = j + 1 - i;
                } else {
                    x = sums[j + 1].x - sums[i].x + sums[n].x;
                    y = sums[j + 1].y - sums[i].y + sums[n].y;
                    x2 = sums[j + 1].x2 - sums[i].x2 + sums[n].x2;
                    xy = sums[j + 1].xy - sums[i].xy + sums[n].xy;
                    y2 = sums[j + 1].y2 - sums[i].y2 + sums[n].y2;
                    k = j + 1 - i + n;
                }

                px = (pt[i].x + pt[j].x) / 2.0 - pt[0].x;
                py = (pt[i].y + pt[j].y) / 2.0 - pt[0].y;
                ey = (pt[j].x - pt[i].x);
                ex = -(pt[j].y - pt[i].y);

                a = ((x2 - 2 * x * px) / k + px * px);
                b = ((xy - x * py - y * px) / k + px * py);
                c = ((y2 - 2 * y * py) / k + py * py);

                s = ex * ex * a + 2 * ex * ey * b + ey * ey * c;

                return Math.sqrt(s);
            }

            var i, j, m, k, n = path.len, pen = new Array(n + 1), prev = new Array(n + 1),
                            clip0 = new Array(n), clip1 = new Array(n + 1),
                            seg0 = new Array(n + 1), seg1 = new Array(n + 1), thispen,
                            best, c;

            for (i = 0; i < n; i++) {
                c = utils.mod(path.lon[utils.mod(i - 1, n)] - 1, n);
                if (c == i) {
                    c = utils.mod(i + 1, n);
                }
                if (c < i) {
                    clip0[i] = n;
                } else {
                    clip0[i] = c;
                }
            }

            j = 1;
            for (i = 0; i < n; i++) {
                while (j <= clip0[i]) {
                    clip1[j] = i;
                    j++;
                }
            }

            i = 0;
            for (j = 0; i < n; j++) {
                seg0[j] = i;
                i = clip0[i];
            }
            seg0[j] = n;
            m = j;

            i = n;
            for (j = m; j > 0; j--) {
                seg1[j] = i;
                i = clip1[i];
            }
            seg1[0] = 0;

            pen[0] = 0;
            for (j = 1; j <= m; j++) {
                for (i = seg1[j]; i <= seg0[j]; i++) {
                    best = -1;
                    for (k = seg0[j - 1]; k >= clip1[i]; k--) {
                        thispen = penalty3(path, k, i) + pen[k];
                        if (best < 0 || thispen < best) {
                            prev[i] = k;
                            best = thispen;
                        }
                    }
                    pen[i] = best;
                }
            }
            path.m = m;
            path.po = new Array(m);

            for (i = n, j = m - 1; i > 0; j--) {
                i = prev[i];
                path.po[j] = i;
            }
        }

        function adjustVertices(path) {

            function pointslope(path, i, j, ctr, dir) {

                var n = path.len, sums = path.sums, x, y, x2, xy, y2, k, a, b, c, lambda2,
                    l, r = 0;

                while (j >= n) {
                    j -= n;
                    r += 1;
                }
                while (i >= n) {
                    i -= n;
                    r -= 1;
                }
                while (j < 0) {
                    j += n;
                    r -= 1;
                }
                while (i < 0) {
                    i += n;
                    r += 1;
                }

                x = sums[j + 1].x - sums[i].x + r * sums[n].x;
                y = sums[j + 1].y - sums[i].y + r * sums[n].y;
                x2 = sums[j + 1].x2 - sums[i].x2 + r * sums[n].x2;
                xy = sums[j + 1].xy - sums[i].xy + r * sums[n].xy;
                y2 = sums[j + 1].y2 - sums[i].y2 + r * sums[n].y2;
                k = j + 1 - i + r * n;

                ctr.x = x / k;
                ctr.y = y / k;

                a = (x2 - x * x / k) / k;
                b = (xy - x * y / k) / k;
                c = (y2 - y * y / k) / k;

                lambda2 = (a + c + Math.sqrt((a - c) * (a - c) + 4 * b * b)) / 2;

                a -= lambda2;
                c -= lambda2;

                if (Math.abs(a) >= Math.abs(c)) {
                    l = Math.sqrt(a * a + b * b);
                    if (l !== 0) {
                        dir.x = -b / l;
                        dir.y = a / l;
                    }
                } else {
                    l = Math.sqrt(c * c + b * b);
                    if (l !== 0) {
                        dir.x = -c / l;
                        dir.y = b / l;
                    }
                }
                if (l === 0) {
                    dir.x = dir.y = 0;
                }
            }

            var m = path.m, po = path.po, n = path.len, pt = path.pt, x0 = path.x0,
                y0 = path.y0, ctr = new Array(m), dir = new Array(m), q = new Array(m),
                v = new Array(3), d, i, j, k, l, s = new Point();

            path.curve = new Curve(m);

            for (i = 0; i < m; i++) {
                j = po[utils.mod(i + 1, m)];
                j = utils.mod(j - po[i], n) + po[i];
                ctr[i] = new Point();
                dir[i] = new Point();
                pointslope(path, po[i], j, ctr[i], dir[i]);
            }

            for (i = 0; i < m; i++) {
                q[i] = new Quad();
                d = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
                if (d === 0.0) {
                    for (j = 0; j < 3; j++) {
                        for (k = 0; k < 3; k++) {
                            q[i].data[j * 3 + k] = 0;
                        }
                    }
                } else {
                    v[0] = dir[i].y;
                    v[1] = -dir[i].x;
                    v[2] = -v[1] * ctr[i].y - v[0] * ctr[i].x;
                    for (l = 0; l < 3; l++) {
                        for (k = 0; k < 3; k++) {
                            q[i].data[l * 3 + k] = v[l] * v[k] / d;
                        }
                    }
                }
            }

            var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
            for (i = 0; i < m; i++) {
                Q = new Quad();
                w = new Point();

                s.x = pt[po[i]].x - x0;
                s.y = pt[po[i]].y - y0;

                j = utils.mod(i - 1, m);

                for (l = 0; l < 3; l++) {
                    for (k = 0; k < 3; k++) {
                        Q.data[l * 3 + k] = q[j].at(l, k) + q[i].at(l, k);
                    }
                }

                while (1) {

                    det = Q.at(0, 0) * Q.at(1, 1) - Q.at(0, 1) * Q.at(1, 0);
                    if (det !== 0.0) {
                        w.x = (-Q.at(0, 2) * Q.at(1, 1) + Q.at(1, 2) * Q.at(0, 1)) / det;
                        w.y = (Q.at(0, 2) * Q.at(1, 0) - Q.at(1, 2) * Q.at(0, 0)) / det;
                        break;
                    }

                    if (Q.at(0, 0) > Q.at(1, 1)) {
                        v[0] = -Q.at(0, 1);
                        v[1] = Q.at(0, 0);
                    } else if (Q.at(1, 1)) {
                        v[0] = -Q.at(1, 1);
                        v[1] = Q.at(1, 0);
                    } else {
                        v[0] = 1;
                        v[1] = 0;
                    }
                    d = v[0] * v[0] + v[1] * v[1];
                    v[2] = -v[1] * s.y - v[0] * s.x;
                    for (l = 0; l < 3; l++) {
                        for (k = 0; k < 3; k++) {
                            Q.data[l * 3 + k] += v[l] * v[k] / d;
                        }
                    }
                }
                dx = Math.abs(w.x - s.x);
                dy = Math.abs(w.y - s.y);
                if (dx <= 0.5 && dy <= 0.5) {
                    path.curve.vertex[i] = new Point(w.x + x0, w.y + y0);
                    continue;
                }

                min = utils.quadform(Q, s);
                xmin = s.x;
                ymin = s.y;

                if (Q.at(0, 0) !== 0.0) {
                    for (z = 0; z < 2; z++) {
                        w.y = s.y - 0.5 + z;
                        w.x = -(Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
                        dx = Math.abs(w.x - s.x);
                        cand = utils.quadform(Q, w);
                        if (dx <= 0.5 && cand < min) {
                            min = cand;
                            xmin = w.x;
                            ymin = w.y;
                        }
                    }
                }

                if (Q.at(1, 1) !== 0.0) {
                    for (z = 0; z < 2; z++) {
                        w.x = s.x - 0.5 + z;
                        w.y = -(Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
                        dy = Math.abs(w.y - s.y);
                        cand = utils.quadform(Q, w);
                        if (dy <= 0.5 && cand < min) {
                            min = cand;
                            xmin = w.x;
                            ymin = w.y;
                        }
                    }
                }

                for (l = 0; l < 2; l++) {
                    for (k = 0; k < 2; k++) {
                        w.x = s.x - 0.5 + l;
                        w.y = s.y - 0.5 + k;
                        cand = utils.quadform(Q, w);
                        if (cand < min) {
                            min = cand;
                            xmin = w.x;
                            ymin = w.y;
                        }
                    }
                }

                path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
            }
        }

        function reverse(path) {
            var curve = path.curve, m = curve.n, v = curve.vertex, i, j, tmp;

            for (i = 0, j = m - 1; i < j; i++, j--) {
                tmp = v[i];
                v[i] = v[j];
                v[j] = tmp;
            }
        }

        function smooth(path) {
            var m = path.curve.n, curve = path.curve;

            var i, j, k, dd, denom, alpha, p2, p3, p4;

            for (i = 0; i < m; i++) {
                j = utils.mod(i + 1, m);
                k = utils.mod(i + 2, m);
                p4 = utils.interval(1 / 2.0, curve.vertex[k], curve.vertex[j]);

                denom = utils.ddenom(curve.vertex[i], curve.vertex[k]);
                if (denom !== 0.0) {
                    dd = utils.dpara(curve.vertex[i], curve.vertex[j], curve.vertex[k]) /
                         denom;
                    dd = Math.abs(dd);
                    alpha = dd > 1 ? (1 - 1.0 / dd) : 0;
                    alpha = alpha / 0.75;
                } else {
                    alpha = 4 / 3.0;
                }
                curve.alpha0[j] = alpha;

                if (alpha >= self._params.alphaMax) {
                    curve.tag[j] = 'CORNER';
                    curve.c[3 * j + 1] = curve.vertex[j];
                    curve.c[3 * j + 2] = p4;
                } else {
                    if (alpha < 0.55) {
                        alpha = 0.55;
                    } else if (alpha > 1) {
                        alpha = 1;
                    }
                    p2 = utils.interval(0.5 + 0.5 * alpha, curve.vertex[i],
                                        curve.vertex[j]);
                    p3 = utils.interval(0.5 + 0.5 * alpha, curve.vertex[k],
                                        curve.vertex[j]);
                    curve.tag[j] = 'CURVE';
                    curve.c[3 * j + 0] = p2;
                    curve.c[3 * j + 1] = p3;
                    curve.c[3 * j + 2] = p4;
                }
                curve.alpha[j] = alpha;
                curve.beta[j] = 0.5;
            }
            curve.alphaCurve = 1;
        }

        function optiCurve(path) {

            function opti_penalty(path, i, j, res, opttolerance, convc, areac) {
                var m = path.curve.n, curve = path.curve, vertex = curve.vertex, k, k1,
                    k2, conv, i1, area, alpha, d, d1, d2, p0, p1, p2, p3, pt, A, R, A1,
                    A2, A3, A4, s, t;

                if (i == j) {
                    return 1;
                }

                k = i;
                i1 = utils.mod(i + 1, m);
                k1 = utils.mod(k + 1, m);
                conv = convc[k1];
                if (conv === 0) {
                    return 1;
                }
                d = utils.ddist(vertex[i], vertex[i1]);
                for (k = k1; k != j; k = k1) {
                    k1 = utils.mod(k + 1, m);
                    k2 = utils.mod(k + 2, m);
                    if (convc[k1] != conv) {
                        return 1;
                    }
                    if (utils.sign(utils.cprod(vertex[i], vertex[i1], vertex[k1],
                                               vertex[k2])) != conv) {
                        return 1;
                    }
                    if (utils.iprod1(vertex[i], vertex[i1], vertex[k1], vertex[k2]) <
                        d * utils.ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
                        return 1;
                    }
                }

                p0 = curve.c[utils.mod(i, m) * 3 + 2].copy();
                p1 = vertex[utils.mod(i + 1, m)].copy();
                p2 = vertex[utils.mod(j, m)].copy();
                p3 = curve.c[utils.mod(j, m) * 3 + 2].copy();

                area = areac[j] - areac[i];
                area -=
                    utils.dpara(vertex[0], curve.c[i * 3 + 2], curve.c[j * 3 + 2]) / 2;
                if (i >= j) {
                    area += areac[m];
                }

                A1 = utils.dpara(p0, p1, p2);
                A2 = utils.dpara(p0, p1, p3);
                A3 = utils.dpara(p0, p2, p3);

                A4 = A1 + A3 - A2;

                if (A2 == A1) {
                    return 1;
                }

                t = A3 / (A3 - A4);
                s = A2 / (A2 - A1);
                A = A2 * t / 2.0;

                if (A === 0.0) {
                    return 1;
                }

                R = area / A;
                alpha = 2 - Math.sqrt(4 - R / 0.3);

                res.c[0] = utils.interval(t * alpha, p0, p1);
                res.c[1] = utils.interval(s * alpha, p3, p2);
                res.alpha = alpha;
                res.t = t;
                res.s = s;

                p1 = res.c[0].copy();
                p2 = res.c[1].copy();

                res.pen = 0;

                for (k = utils.mod(i + 1, m); k != j; k = k1) {
                    k1 = utils.mod(k + 1, m);
                    t = utils.tangent(p0, p1, p2, p3, vertex[k], vertex[k1]);
                    if (t < -0.5) {
                        return 1;
                    }
                    pt = utils.bezier(t, p0, p1, p2, p3);
                    d = utils.ddist(vertex[k], vertex[k1]);
                    if (d === 0.0) {
                        return 1;
                    }
                    d1 = utils.dpara(vertex[k], vertex[k1], pt) / d;
                    if (Math.abs(d1) > opttolerance) {
                        return 1;
                    }
                    if (utils.iprod(vertex[k], vertex[k1], pt) < 0 ||
                        utils.iprod(vertex[k1], vertex[k], pt) < 0) {
                        return 1;
                    }
                    res.pen += d1 * d1;
                }

                for (k = i; k != j; k = k1) {
                    k1 = utils.mod(k + 1, m);
                    t = utils.tangent(p0, p1, p2, p3, curve.c[k * 3 + 2],
                                      curve.c[k1 * 3 + 2]);
                    if (t < -0.5) {
                        return 1;
                    }
                    pt = utils.bezier(t, p0, p1, p2, p3);
                    d = utils.ddist(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
                    if (d === 0.0) {
                        return 1;
                    }
                    d1 = utils.dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
                    d2 =
                        utils.dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) /
                        d;
                    d2 *= 0.75 * curve.alpha[k1];
                    if (d2 < 0) {
                        d1 = -d1;
                        d2 = -d2;
                    }
                    if (d1 < d2 - opttolerance) {
                        return 1;
                    }
                    if (d1 < d2) {
                        res.pen += (d1 - d2) * (d1 - d2);
                    }
                }

                return 0;
            }

            var curve = path.curve, m = curve.n, vert = curve.vertex,
                pt = new Array(m + 1), pen = new Array(m + 1), len = new Array(m + 1),
                opt = new Array(m + 1), om, i, j, r, o = new Opti(), p0, i1, area, alpha,
                ocurve, s, t;

            var convc = new Array(m), areac = new Array(m + 1);

            for (i = 0; i < m; i++) {
                if (curve.tag[i] == 'CURVE') {
                    convc[i] = utils.sign(utils.dpara(vert[utils.mod(i - 1, m)], vert[i],
                                                      vert[utils.mod(i + 1, m)]));
                } else {
                    convc[i] = 0;
                }
            }

            area = 0.0;
            areac[0] = 0.0;
            p0 = curve.vertex[0];
            for (i = 0; i < m; i++) {
                i1 = utils.mod(i + 1, m);
                if (curve.tag[i1] == 'CURVE') {
                    alpha = curve.alpha[i1];
                    area +=
                        0.3 * alpha * (4 - alpha) *
                        utils.dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) /
                        2;
                    area += utils.dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
                }
                areac[i + 1] = area;
            }

            pt[0] = -1;
            pen[0] = 0;
            len[0] = 0;


            for (j = 1; j <= m; j++) {
                pt[j] = j - 1;
                pen[j] = pen[j - 1];
                len[j] = len[j - 1] + 1;

                for (i = j - 2; i >= 0; i--) {
                    r = opti_penalty(path, i, utils.mod(j, m), o,
                                     self._params.optTolerance, convc, areac);
                    if (r) {
                        break;
                    }
                    if (len[j] > len[i] + 1 ||
                        (len[j] == len[i] + 1 && pen[j] > pen[i] + o.pen)) {
                        pt[j] = i;
                        pen[j] = pen[i] + o.pen;
                        len[j] = len[i] + 1;
                        opt[j] = o;
                        o = new Opti();
                    }
                }
            }
            om = len[m];
            ocurve = new Curve(om);
            s = new Array(om);
            t = new Array(om);

            j = m;
            for (i = om - 1; i >= 0; i--) {
                if (pt[j] == j - 1) {
                    ocurve.tag[i] = curve.tag[utils.mod(j, m)];
                    ocurve.c[i * 3 + 0] = curve.c[utils.mod(j, m) * 3 + 0];
                    ocurve.c[i * 3 + 1] = curve.c[utils.mod(j, m) * 3 + 1];
                    ocurve.c[i * 3 + 2] = curve.c[utils.mod(j, m) * 3 + 2];
                    ocurve.vertex[i] = curve.vertex[utils.mod(j, m)];
                    ocurve.alpha[i] = curve.alpha[utils.mod(j, m)];
                    ocurve.alpha0[i] = curve.alpha0[utils.mod(j, m)];
                    ocurve.beta[i] = curve.beta[utils.mod(j, m)];
                    s[i] = t[i] = 1.0;
                } else {
                    ocurve.tag[i] = 'CURVE';
                    ocurve.c[i * 3 + 0] = opt[j].c[0];
                    ocurve.c[i * 3 + 1] = opt[j].c[1];
                    ocurve.c[i * 3 + 2] = curve.c[utils.mod(j, m) * 3 + 2];
                    ocurve.vertex[i] =
                        utils.interval(opt[j].s, curve.c[utils.mod(j, m) * 3 + 2],
                                       vert[utils.mod(j, m)]);
                    ocurve.alpha[i] = opt[j].alpha;
                    ocurve.alpha0[i] = opt[j].alpha;
                    s[i] = opt[j].s;
                    t[i] = opt[j].t;
                }
                j = pt[j];
            }

            for (i = 0; i < om; i++) {
                i1 = utils.mod(i + 1, om);
                ocurve.beta[i] = s[i] / (s[i] + t[i1]);
            }

            ocurve.alphaCurve = 1;
            path.curve = ocurve;
        }

        for (var i = 0; i < this._pathlist.length; i++) {
            var path = this._pathlist[i];
            calcSums(path);
            calcLon(path);
            bestPolygon(path);
            adjustVertices(path);

            if (path.sign === '-') {
                reverse(path);
            }

            smooth(path);

            if (self._params.optCurve) {
                optiCurve(path);
            }
        }
    },

    /**
     * Validates some of parameters
     * @param params
     * @private
     */
    _validateParameters: function(params) {
        if (params && params.turnPolicy &&
            SUPPORTED_TURNPOLICY_VALUES.indexOf(params.turnPolicy) === -1) {
            var goodVals = '\'' + SUPPORTED_TURNPOLICY_VALUES.join('\', \'') + '\'';

            throw new Error('Bad turnPolicy value. Allowed values are: ' + goodVals);
        }

        if (params && params.threshold != null &&
            params.threshold !== Potrace.THRESHOLD_AUTO) {
            if (typeof params.threshold !== 'number' ||
                !utils.between(params.threshold, 0, 255)) {
                throw new Error(
                    'Bad threshold value. Expected to be an integer in range 0..255');
            }
        }

        if (params && params.optCurve != null && typeof params.optCurve !== 'boolean') {
            throw new Error('\'optCurve\' must be Boolean');
        }
    },

    _processLoadedImage: function(image) {
        var bitmap = new Bitmap(image.bitmap.width, image.bitmap.height);
        var pixels = image.bitmap.data;

        image.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {
            // We want background underneath non-opaque regions to be white

            var opacity = pixels[idx + 3] / 255,
                r = 255 + (pixels[idx + 0] - 255) * opacity,
                g = 255 + (pixels[idx + 1] - 255) * opacity,
                b = 255 + (pixels[idx + 2] - 255) * opacity;

            bitmap.data[idx / 4] = utils.luminance(r, g, b);
        });

        this._luminanceData = bitmap;
        this._imageLoaded = true;
    },

    /**
     * Reads given image. Uses {@link Jimp} under the hood, so target can be whatever Jimp
     * can take
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link
     *     Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or
     *     BMP
     * @param {Function} callback
     */
    loadImage: function(target, callback) {
        var self = this;
        var jobId = {};

        this._imageLoadingIdentifier = jobId;
        this._imageLoaded = false;

        if (target instanceof Jimp) {
            this._imageLoadingIdentifier = null;
            this._imageLoaded = true;
            self._processLoadedImage(target);
            callback.call(self, null);
        } else {
            Jimp.read(target, function(err, img) {
                var sourceChanged = self._imageLoadingIdentifier !== jobId;

                if (sourceChanged) {
                    var error = err ? err : new Error('Another image was loaded instead');
                    return callback.call(self, error);
                }

                self._imageLoadingIdentifier = null;
                self._processLoadedImage(img);
                callback.call(self, null);
            });
        }
    },

    /**
     * Sets algorithm parameters
     * @param {Potrace~Options} newParams
     */
    setParameters: function(newParams) {
        var key, tmpOldVal;

        this._validateParameters(newParams);

        for (key in this._params) {
            if (this._params.hasOwnProperty(key) && newParams.hasOwnProperty(key)) {
                tmpOldVal = this._params[key];
                this._params[key] = newParams[key];

                if (tmpOldVal !== this._params[key] &&
                    ['color', 'background'].indexOf(key) === -1) {
                    this._processed = false;
                }
            }
        }
    },

    /**
     * Generates just <path> tag without rest of the SVG file
     *
     * @param {String} [fillColor] - overrides color from parameters
     * @returns {String}
     */
    getPathTag: function(fillColor, scale) {
        fillColor = arguments.length === 0 ? this._params.color : fillColor;

        if (fillColor === Potrace.COLOR_AUTO) {
            fillColor = this._params.blackOnWhite ? 'black' : 'white';
        }

        if (!this._imageLoaded) {
            throw new Error('Image should be loaded first');
        }

        if (!this._processed) {
            this._bmToPathlist();
            this._processPath();
            this._processed = true;
        }

        var tag = '<path d="';

        tag += this._pathlist
                   .map(function(path) {
                       return utils.renderCurve(path.curve, scale);
                   })
                   .join(' ');

        tag += '" stroke="none" fill="' + fillColor + '" fill-rule="evenodd"/>';

        return tag;
    },

    /**
     * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
     * so it could be changed with <use> tag
     *
     * @param id
     * @returns {string}
     */
    getSymbol: function(id) {
        return '<symbol ' +
               'viewBox="0 0 ' + this._luminanceData.width + ' ' +
               this._luminanceData.height + '" ' +
               'id="' + id + '">' + this.getPathTag('') + '</symbol>';
    },

    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
        var width = this._params.width || this._luminanceData.width;
        var height = this._params.height || this._luminanceData.height;
        var scale = {
            x: this._params.width ? this._params.width / this._luminanceData.width : 1,
            y: this._params.height ? this._params.height / this._luminanceData.height : 1,
        };

        return '<svg xmlns="http://www.w3.org/2000/svg" ' +
               'width="' + width + '" ' +
               'height="' + height + '" ' +
               'viewBox="0 0 ' + width + ' ' + height + '" ' +
               'version="1.1">\n' +
               (this._params.background !== Potrace.COLOR_TRANSPARENT ?
                    '\t<rect x="0" y="0" width="100%" height="100%" fill="' +
                        this._params.background + '" />\n' :
                    '') +
               '\t' + this.getPathTag(this._params.color, scale) + '\n' +
               '</svg>';
    }
};

module.exports = Potrace;

/**
 * Potrace options
 *
 * @typedef {Object} Potrace~Options
 * @property {*}       [turnPolicy]   - how to resolve ambiguities in path decomposition
 * (default Potrace.TURNPOLICY_MINORITY)
 * @property {Number}  [turdSize]     - suppress speckles of up to this size (default 2)
 * @property {Number}  [alphaMax]     - corner threshold parameter (default 1)
 * @property {Boolean} [optCurve]     - curve optimization (default true)
 * @property {Number}  [optTolerance] - curve optimization tolerance (default 0.2)
 * @property {Number}  [threshold]    - threshold below which color is considered black
 * (0..255, default Potrace.THRESHOLD_AUTO)
 * @property {Boolean} [blackOnWhite] - specifies colors by which side from threshold
 * should be traced (default true)
 * @property {string}  [color]        - foreground color (default: 'auto' (black or
 * white)) Will be ignored when exporting as <symbol>
 * @property {string}  [background]   - background color (default: 'transparent') Will be
 * ignored when exporting as <symbol>
 */

/**
 * Jimp module
 * @external Jimp
 * @see https://www.npmjs.com/package/jimp
 */
================================================================================
--------------------------------------------------------------------------------
# index.js
# lib/index.js
# ./lib/index.js
# Content:
********************************************************************************
// index.js
'use strict';

var Potrace = require('./Potrace');
var Posterizer = require('./Posterizer');

/**
 * Wrapper for Potrace that simplifies use down to one function call
 *
 * @param {string|Buffer|Jimp} file Source image, file path or {@link Jimp} instance
 * @param {Potrace~Options} [options]
 * @param {traceCallback} cb Callback function. Accepts 3 arguments: error, svg content
 *     and instance of {@link Potrace} (so it could be reused with different set of
 *     parameters)
 */
function trace(file, options, cb) {
    if (arguments.length === 2) {
        cb = options;
        options = {};
    }

    var potrace = new Potrace(options);

    potrace.loadImage(file, function(err) {
        if (err) {
            return cb(err);
        }
        cb(null, potrace.getSVG(), potrace);
    });
}

/**
 * Wrapper for Potrace that simplifies use down to one function call
 *
 * @param {string|Buffer|Jimp} file Source image, file path or {@link Jimp} instance
 * @param {Posterizer~Options} [options]
 * @param {posterizeCallback} cb Callback function. Accepts 3 arguments: error, svg
 *     content and instance of {@link Potrace} (so it could be reused with different set
 *     of parameters)
 */
function posterize(file, options, cb) {
    if (arguments.length === 2) {
        cb = options;
        options = {};
    }

    var posterizer = new Posterizer(options);

    posterizer.loadImage(file, function(err) {
        if (err) {
            return cb(err);
        }
        cb(null, posterizer.getSVG(), posterizer);
    });
}

module.exports = {
    trace : trace,
    posterize : posterize,
    Potrace : Potrace,
    Posterizer : Posterizer
};

/**
 * Callback for trace method
 * @callback traceCallback
 * @param {Error|null} err
 * @param {string} svg SVG document contents
 * @param {Potrace} [instance] Potrace class instance
 */

/**
 * Callback for posterize method
 * @callback posterizeCallback
 * @param {Error|null} err
 * @param {string} svg SVG document contents
 * @param {Posterizer} [instance] Posterizer class instance
 */
================================================================================
--------------------------------------------------------------------------------
# Posterizer.js
# lib/Posterizer.js
# ./lib/Posterizer.js
# Content:
********************************************************************************
// Posterizer.js
'use strict';

var Potrace = require('./Potrace');
var utils = require('./utils');

/**
 * Takes multiple samples using {@link Potrace} with different threshold
 * settings and combines output into a single file.
 *
 * @param {Posterizer~Options} [options]
 * @constructor
 */
function Posterizer(options) {
    this._potrace = new Potrace();

    this._calculatedThreshold = null;

    this._params = {
        threshold: Potrace.THRESHOLD_AUTO,
        blackOnWhite: true,
        steps: Posterizer.STEPS_AUTO,
        background: Potrace.COLOR_TRANSPARENT,
        fillStrategy: Posterizer.FILL_DOMINANT,
        rangeDistribution: Posterizer.RANGES_AUTO
    };

    if (options) {
        this.setParameters(options);
    }
}

// Inherit constants from Potrace class
for (var key in Potrace) {
    if (Object.prototype.hasOwnProperty.call(Potrace, key) && key === key.toUpperCase()) {
        Posterizer[key] = Potrace[key];
    }
}

Posterizer.STEPS_AUTO = -1;
Posterizer.FILL_SPREAD = 'spread';
Posterizer.FILL_DOMINANT = 'dominant';
Posterizer.FILL_MEDIAN = 'median';
Posterizer.FILL_MEAN = 'mean';

Posterizer.RANGES_AUTO = 'auto';
Posterizer.RANGES_EQUAL = 'equal';

Posterizer.prototype = {
    /**
     * Fine tuning to color ranges.
     *
     * If last range (featuring most saturated color) is larger than 10% of color space
     * (25 units) then we want to add another color stop, that hopefully will include
     * darkest pixels, improving presence of shadows and line art
     *
     * @param ranges
     * @private
     */
    _addExtraColorStop: function(ranges) {
        var blackOnWhite = this._params.blackOnWhite;
        var lastColorStop = ranges[ranges.length - 1];
        var lastRangeFrom = blackOnWhite ? 0 : lastColorStop.value;
        var lastRangeTo = blackOnWhite ? lastColorStop.value : 255;

        if (lastRangeTo - lastRangeFrom > 25 && lastColorStop.colorIntensity !== 1) {
            var histogram = this._getImageHistogram();
            var levels = histogram.getStats(lastRangeFrom, lastRangeTo).levels;

            var newColorStop =
                levels.mean + levels.stdDev <= 25 ? levels.mean + levels.stdDev :
                levels.mean - levels.stdDev <= 25 ? levels.mean - levels.stdDev :
                                                    25;

            var newStats = (blackOnWhite ? histogram.getStats(0, newColorStop) :
                                           histogram.getStats(newColorStop, 255));
            var color = newStats.levels.mean;

            ranges.push({
                value: Math.abs((blackOnWhite ? 0 : 255) - newColorStop),
                colorIntensity:
                    isNaN(color) ? 0 : ((blackOnWhite ? 255 - color : color) / 255)
            });
        }

        return ranges;
    },


    /**
     * Calculates color intensity for each element of numeric array
     *
     * @param {number[]} colorStops
     * @returns {{ levels: number, colorIntensity: number }[]}
     * @private
     */
    _calcColorIntensity: function(colorStops) {
        var blackOnWhite = this._params.blackOnWhite;
        var colorSelectionStrat = this._params.fillStrategy;
        var histogram = colorSelectionStrat !== Posterizer.FILL_SPREAD ?
                            this._getImageHistogram() :
                            null;
        var fullRange = Math.abs(this._paramThreshold() - (blackOnWhite ? 0 : 255));

        return colorStops.map(function(threshold, index) {
            var nextValue = index + 1 === colorStops.length ? (blackOnWhite ? -1 : 256) :
                                                              colorStops[index + 1];
            var rangeStart = Math.round(blackOnWhite ? nextValue + 1 : threshold);
            var rangeEnd = Math.round(blackOnWhite ? threshold : nextValue - 1);
            var factor = index / (colorStops.length - 1);
            var intervalSize = rangeEnd - rangeStart;
            var stats = histogram.getStats(rangeStart, rangeEnd);
            var color = -1;

            if (stats.pixels === 0) {
                return {value: threshold, colorIntensity: 0};
            }

            switch (colorSelectionStrat) {
                case Posterizer.FILL_SPREAD:
                    // We want it to be 0 (255 when white on black) at the most saturated
                    // end, so...
                    color = (blackOnWhite ? rangeStart : rangeEnd) +
                            (blackOnWhite ? 1 : -1) * intervalSize *
                                Math.max(0.5, fullRange / 255) * factor;
                    break;
                case Posterizer.FILL_DOMINANT:
                    color = histogram.getDominantColor(rangeStart, rangeEnd,
                                                       utils.clamp(intervalSize, 1, 5));
                    break;
                case Posterizer.FILL_MEAN:
                    color = stats.levels.mean;
                    break;
                case Posterizer.FILL_MEDIAN:
                    color = stats.levels.median;
                    break;
            }

            // We don't want colors to be too close to each other, so we introduce some
            // spacing in between
            if (index !== 0) {
                color =
                    blackOnWhite ?
                        utils.clamp(color, rangeStart,
                                    rangeEnd - Math.round(intervalSize * 0.1)) :
                        utils.clamp(color, rangeStart + Math.round(intervalSize * 0.1),
                                    rangeEnd);
            }

            return {
                value: threshold,
                colorIntensity:
                    color === -1 ? 0 : ((blackOnWhite ? 255 - color : color) / 255)
            };
        });
    },

    /**
     * @returns {Histogram}
     * @private
     */
    _getImageHistogram: function() {
        return this._potrace._luminanceData.histogram();
    },

    /**
     * Processes threshold, steps and rangeDistribution parameters and returns normalized
     * array of color stops
     * @returns {*}
     * @private
     */
    _getRanges: function() {
        var steps = this._paramSteps();

        if (!Array.isArray(steps)) {
            return this._params.rangeDistribution === Posterizer.RANGES_AUTO ?
                       this._getRangesAuto() :
                       this._getRangesEquallyDistributed();
        }

        // Steps is array of thresholds and we want to preprocess it

        var colorStops = [];
        var threshold = this._paramThreshold();
        var lookingForDarkPixels = this._params.blackOnWhite;

        steps.forEach(function(item) {
            if (colorStops.indexOf(item) === -1 && utils.between(item, 0, 255)) {
                colorStops.push(item);
            }
        });

        if (!colorStops.length) {
            colorStops.push(threshold);
        }

        colorStops = colorStops.sort(function(a, b) {
            return a < b === lookingForDarkPixels ? 1 : -1;
        });

        if (lookingForDarkPixels && colorStops[0] < threshold) {
            colorStops.unshift(threshold);
        } else if (!lookingForDarkPixels &&
                   colorStops[colorStops.length - 1] < threshold) {
            colorStops.push(threshold);
        }

        return this._calcColorIntensity(colorStops);
    },

    /**
     * Calculates given (or lower) number of thresholds using automatic thresholding
     * algorithm
     * @returns {*}
     * @private
     */
    _getRangesAuto: function() {
        var histogram = this._getImageHistogram();
        var steps = this._paramSteps(true);
        var colorStops;

        if (this._params.threshold === Potrace.THRESHOLD_AUTO) {
            colorStops = histogram.multilevelThresholding(steps);
        } else {
            var threshold = this._paramThreshold();

            colorStops = this._params.blackOnWhite ?
                             histogram.multilevelThresholding(steps - 1, 0, threshold) :
                             histogram.multilevelThresholding(steps - 1, threshold, 255);

            if (this._params.blackOnWhite) {
                colorStops.push(threshold);
            } else {
                colorStops.unshift(threshold);
            }
        }

        if (this._params.blackOnWhite) {
            colorStops = colorStops.reverse();
        }

        return this._calcColorIntensity(colorStops);
    },

    /**
     * Calculates color stops and color representing each segment, returning them
     * from least to most intense color (black or white, depending on blackOnWhite
     * parameter)
     *
     * @private
     */
    _getRangesEquallyDistributed: function() {
        var blackOnWhite = this._params.blackOnWhite;
        var colorsToThreshold =
            blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();
        var steps = this._paramSteps();

        var stepSize = colorsToThreshold / steps;
        var colorStops = [];
        var i = steps - 1, factor, threshold;

        while (i >= 0) {
            factor = i / (steps - 1);
            threshold = Math.min(colorsToThreshold, (i + 1) * stepSize);
            threshold = blackOnWhite ? threshold : 255 - threshold;
            i--;

            colorStops.push(threshold);
        }

        return this._calcColorIntensity(colorStops);
    },

    /**
     * Returns valid steps value
     * @param {Boolean} [count=false]
     * @returns {number|number[]}
     * @private
     */
    _paramSteps: function(count) {
        var steps = this._params.steps;

        if (Array.isArray(steps)) {
            return count ? steps.length : steps;
        }

        if (steps === Posterizer.STEPS_AUTO &&
            this._params.threshold === Potrace.THRESHOLD_AUTO) {
            return 4;
        }

        var blackOnWhite = this._params.blackOnWhite;
        var colorsCount =
            blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();

        return steps === Posterizer.STEPS_AUTO ?
                   (colorsCount > 200 ? 4 : 3) :
                   Math.min(colorsCount, Math.max(2, steps));
    },

    /**
     * Returns valid threshold value
     * @returns {number}
     * @private
     */
    _paramThreshold: function() {
        if (this._calculatedThreshold !== null) {
            return this._calculatedThreshold;
        }

        if (this._params.threshold !== Potrace.THRESHOLD_AUTO) {
            this._calculatedThreshold = this._params.threshold;
            return this._calculatedThreshold;
        }

        var twoThresholds = this._getImageHistogram().multilevelThresholding(2);
        this._calculatedThreshold =
            this._params.blackOnWhite ? twoThresholds[1] : twoThresholds[0];
        this._calculatedThreshold = this._calculatedThreshold || 128;

        return this._calculatedThreshold;
    },

    /**
     * Running potrace on the image multiple times with different thresholds and returns
     * an array of path tags
     *
     * @param {Boolean} [noFillColor]
     * @returns {string[]}
     * @private
     */
    _pathTags: function(noFillColor) {
        var ranges = this._getRanges();
        var potrace = this._potrace;
        var blackOnWhite = this._params.blackOnWhite;

        if (ranges.length >= 10) {
            ranges = this._addExtraColorStop(ranges);
        }

        potrace.setParameters({blackOnWhite: blackOnWhite});

        var actualPrevLayersOpacity = 0;

        return ranges.map(function(colorStop) {
            var thisLayerOpacity = colorStop.colorIntensity;

            if (thisLayerOpacity === 0) {
                return '';
            }

            // NOTE: With big number of layers (something like 70) there will be
            // noticeable math error on rendering side. In Chromium at least image will
            // end up looking brighter overall compared to the same layers painted in
            // solid colors. However it works fine with sane number of layers, and it's
            // not like we can do much about it.

            var calculatedOpacity = (!actualPrevLayersOpacity || thisLayerOpacity === 1) ?
                                        thisLayerOpacity :
                                        ((actualPrevLayersOpacity - thisLayerOpacity) /
                                         (actualPrevLayersOpacity - 1));

            calculatedOpacity =
                utils.clamp(parseFloat(calculatedOpacity.toFixed(3)), 0, 1);
            actualPrevLayersOpacity = actualPrevLayersOpacity +
                                      (1 - actualPrevLayersOpacity) * calculatedOpacity;

            potrace.setParameters({threshold: colorStop.value});

            var element = noFillColor ? potrace.getPathTag('') : potrace.getPathTag();
            element =
                utils.setHtmlAttr(element, 'fill-opacity', calculatedOpacity.toFixed(3));

            var canBeIgnored = calculatedOpacity === 0 || element.indexOf(' d=""') !== -1;

            // var c = Math.round(Math.abs((blackOnWhite ? 255 : 0) - 255 *
            // thisLayerOpacity)); element = utils.setHtmlAttr(element, 'fill',
            // 'rgb('+c+', '+c+', '+c+')'); element = utils.setHtmlAttr(element,
            // 'fill-opacity', '');

            return canBeIgnored ? '' : element;
        });
    },

    /**
     * Loads image.
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link
     *     Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or
     *     BMP
     * @param {Function} callback
     */
    loadImage: function(target, callback) {
        var self = this;

        this._potrace.loadImage(target, function(err) {
            self._calculatedThreshold = null;
            callback.call(self, err);
        });
    },

    /**
     * Sets parameters. Accepts same object as {Potrace}
     *
     * @param {Posterizer~Options} params
     */
    setParameters: function(params) {
        if (!params) {
            return;
        }

        this._potrace.setParameters(params);

        if (params.steps && !Array.isArray(params.steps) &&
            (!utils.isNumber(params.steps) || !utils.between(params.steps, 1, 255))) {
            throw new Error('Bad \'steps\' value');
        }

        for (var key in this._params) {
            if (this._params.hasOwnProperty(key) && params.hasOwnProperty(key)) {
                this._params[key] = params[key];
            }
        }

        this._calculatedThreshold = null;
    },

    /**
     * Returns image as <symbol> tag. Always has viewBox specified
     *
     * @param {string} id
     */
    getSymbol: function(id) {
        var width = this._potrace._luminanceData.width;
        var height = this._potrace._luminanceData.height;
        var paths = this._pathTags(true);

        return '<symbol viewBox="0 0 ' + width + ' ' + height + '" id="' + id + '">' +
               paths.join('') + '</symbol>';
    },

    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
        var width = this._potrace._luminanceData.width,
            height = this._potrace._luminanceData.height;

        var tags = this._pathTags(false);

        var svg = '<svg xmlns="http://www.w3.org/2000/svg" ' +
                  'width="' + width + '" ' +
                  'height="' + height + '" ' +
                  'viewBox="0 0 ' + width + ' ' + height + '" ' +
                  'version="1.1">\n\t' +
                  (this._params.background !== Potrace.COLOR_TRANSPARENT ?
                       '<rect x="0" y="0" width="100%" height="100%" fill="' +
                           this._params.background + '" />\n\t' :
                       '') +
                  tags.join('\n\t') + '\n</svg>';

        return svg.replace(/\n(?:\t*\n)+(\t*)/g, '\n$1');
    }
};

module.exports = Posterizer;

/**
 * Posterizer options
 *
 * @typedef {Potrace~Options} Posterizer~Options
 * @property {Number} [steps]   - Number of samples that needs to be taken (and number of
 * layers in SVG). (default: Posterizer.STEPS_AUTO, which most likely will result in 3,
 * sometimes 4)
 * @property {*} [fillStrategy] - How to select fill color for color ranges - equally
 * spread or dominant. (default: Posterizer.FILL_DOMINANT)
 * @property {*} [rangeDistribution] - How to choose thresholds in-between - after equal
 * intervals or automatically balanced. (default: Posterizer.RANGES_AUTO)
 */

================================================================================
--------------------------------------------------------------------------------
# utils.js
# lib/utils.js
# ./lib/utils.js
# Content:
********************************************************************************
// utils.js
'use strict';

var Point = require('./types/Point');
var attrRegexps = {};

function getAttrRegexp(attrName) {
    if (attrRegexps[attrName]) {
        return attrRegexps[attrName];
    }

    attrRegexps[attrName] = new RegExp(' ' + attrName + '="((?:\\\\(?=")"|[^"])+)"', 'i');
    return attrRegexps[attrName];
}

function setHtmlAttribute(html, attrName, value) {
    var attr = ' ' + attrName + '="' + value + '"';

    if (html.indexOf(' ' + attrName + '="') === -1) {
        html = html.replace(/<[a-z]+/i, function(beginning) {
            return beginning + attr;
        });
    } else {
        html = html.replace(getAttrRegexp(attrName), attr);
    }

    return html;
}

function fixed(number) {
    return number.toFixed(3).replace('.000', '');
}

function mod(a, n) {
    return a >= n ? a % n : a >= 0 ? a : n - 1 - (-1 - a) % n;
}

function xprod(p1, p2) {
    return p1.x * p2.y - p1.y * p2.x;
}

function cyclic(a, b, c) {
    if (a <= c) {
        return (a <= b && b < c);
    } else {
        return (a <= b || b < c);
    }
}

function sign(i) {
    return i > 0 ? 1 : i < 0 ? -1 : 0;
}

function quadform(Q, w) {
    var v = new Array(3), i, j, sum;

    v[0] = w.x;
    v[1] = w.y;
    v[2] = 1;
    sum = 0.0;

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            sum += v[i] * Q.at(i, j) * v[j];
        }
    }
    return sum;
}

function interval(lambda, a, b) {
    var res = new Point();

    res.x = a.x + lambda * (b.x - a.x);
    res.y = a.y + lambda * (b.y - a.y);
    return res;
}

function dorth_infty(p0, p2) {
    var r = new Point();

    r.y = sign(p2.x - p0.x);
    r.x = -sign(p2.y - p0.y);

    return r;
}

function ddenom(p0, p2) {
    var r = dorth_infty(p0, p2);

    return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
}

function dpara(p0, p1, p2) {
    var x1, y1, x2, y2;

    x1 = p1.x - p0.x;
    y1 = p1.y - p0.y;
    x2 = p2.x - p0.x;
    y2 = p2.y - p0.y;

    return x1 * y2 - x2 * y1;
}

function cprod(p0, p1, p2, p3) {
    var x1, y1, x2, y2;

    x1 = p1.x - p0.x;
    y1 = p1.y - p0.y;
    x2 = p3.x - p2.x;
    y2 = p3.y - p2.y;

    return x1 * y2 - x2 * y1;
}

function iprod(p0, p1, p2) {
    var x1, y1, x2, y2;

    x1 = p1.x - p0.x;
    y1 = p1.y - p0.y;
    x2 = p2.x - p0.x;
    y2 = p2.y - p0.y;

    return x1 * x2 + y1 * y2;
}

function iprod1(p0, p1, p2, p3) {
    var x1, y1, x2, y2;

    x1 = p1.x - p0.x;
    y1 = p1.y - p0.y;
    x2 = p3.x - p2.x;
    y2 = p3.y - p2.y;

    return x1 * x2 + y1 * y2;
}

function ddist(p, q) {
    return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
}

module.exports = {
  luminance: function (r, g, b) {
    return Math.round(0.2126 * r + 0.7153 * g + 0.0721 * b);
  },

  between: function(val, min, max) {
    return val >= min && val <= max;
  },

  clamp: function(val, min, max) {
    return Math.min(max, Math.max(min, val));
  },

  isNumber: function(val) {
    return typeof val === 'number';
  },

  setHtmlAttr: setHtmlAttribute,

  /**
   * Generates path instructions for given curve
   *
   * @param {Curve} curve
   * @param {Number} [scale]
   * @returns {string}
   */
  renderCurve: function(curve, scale) {
    scale = scale || { x: 1, y: 1 };

    var startingPoint = curve.c[(curve.n - 1) * 3 + 2];

    var path = [
      'M '
      + fixed(startingPoint.x * scale.x) + ' '
      + fixed(startingPoint.y * scale.y)
    ];

    curve.tag.forEach(function(tag, i) {
      var i3 = i * 3;
      var p0 = curve.c[i3];
      var p1 = curve.c[i3 + 1];
      var p2 = curve.c[i3 + 2];

      if (tag === 'CURVE') {
        path.push(
          'C '
          + fixed(p0.x * scale.x) + ' ' + fixed(p0.y * scale.y) + ', '
          + fixed(p1.x * scale.x) + ' ' + fixed(p1.y * scale.y) + ', '
          + fixed(p2.x * scale.x) + ' ' + fixed(p2.y * scale.y)
        );
      } else if (tag === 'CORNER') {
        path.push(
          'L '
          + fixed(p1.x * scale.x) + ' ' + fixed(p1.y * scale.y) + ' '
          + fixed(p2.x * scale.x) + ' ' + fixed(p2.y * scale.y)
        );
      }
    });

    return path.join(' ');
  },

  bezier: function bezier(t, p0, p1, p2, p3) {
    var s = 1 - t, res = new Point();

    res.x = s*s*s*p0.x + 3*(s*s*t)*p1.x + 3*(t*t*s)*p2.x + t*t*t*p3.x;
    res.y = s*s*s*p0.y + 3*(s*s*t)*p1.y + 3*(t*t*s)*p2.y + t*t*t*p3.y;

    return res;
  },

  tangent: function tangent(p0, p1, p2, p3, q0, q1) {
    var A, B, C, a, b, c, d, s, r1, r2;

    A = cprod(p0, p1, q0, q1);
    B = cprod(p1, p2, q0, q1);
    C = cprod(p2, p3, q0, q1);

    a = A - 2 * B + C;
    b = -2 * A + 2 * B;
    c = A;

    d = b * b - 4 * a * c;

    if (a===0 || d<0) {
      return -1.0;
    }

    s = Math.sqrt(d);

    r1 = (-b + s) / (2 * a);
    r2 = (-b - s) / (2 * a);

    if (r1 >= 0 && r1 <= 1) {
      return r1;
    } else if (r2 >= 0 && r2 <= 1) {
      return r2;
    } else {
      return -1.0;
    }
  },

  mod: mod,
  xprod: xprod,
  cyclic: cyclic,
  sign: sign,
  quadform: quadform,
  interval: interval,
  dorth_infty: dorth_infty,
  ddenom: ddenom,
  dpara: dpara,
  cprod: cprod,
  iprod: iprod,
  iprod1: iprod1,
  ddist: ddist
};
================================================================================
